# OpenClaw Thread 与子 Session 完全指南

> 📚 本教程基于 OpenClaw 插件生态，详解 Thread（话题线程）和子 Session（子会话）的区别与使用场景
> 
> 📝 创建时间：2026-02-06

---

## 目录

1. [OpenClaw 插件生态概览](#1-openclaw-插件生态概览)
2. [什么是 Thread](#2-什么是-thread)
3. [什么是子 Session](#3-什么是子-session)
4. [核心区别对比](#4-核心区别对比)
5. [使用场景与最佳实践](#5-使用场景与最佳实践)
6. [总结](#6-总结)

---

## 1. OpenClaw 插件生态概览

OpenClaw（前身 clawdbot → moltbot）的插件系统经历了多次迭代，现已形成完善的技能（Skill）生态：

### 技能分类

| 类型 | 说明 | 示例 |
|------|------|------|
| **系统技能** | OpenClaw 内置的基础能力 | `web_search`, `browser`, `exec` |
| **自定义技能** | 用户自行开发的扩展功能 | `weather`, `pdf`, `pptx` |
| **第三方技能** | 社区共享的技能包 | `bird`, `notion`, `healthcheck` |

### 技能的核心价值

- 🔧 **功能扩展**：让 AI 能够操作外部系统（文件、浏览器、API 等）
- 🧩 **模块化设计**：按需加载，避免资源浪费
- 🔄 **生态共享**：社区贡献，持续进化

---

## 2. 什么是 Thread

### 2.1 概念定义

**Thread（线程/会话线程）**是 Discord 等聊天平台的功能，用于在频道内创建子话题讨论区。

在 OpenClaw 的语境中，Thread 主要指：
- Discord 的 Thread 功能（子频道讨论串）
- 用于组织相关消息的嵌套对话

### 2.2 在 Discord 中的使用

```
主频道 (#general)
├── 消息 1
├── 消息 2
├── 🧵 Thread: "项目讨论"     ← 创建 Thread
│   ├── 回复 1
│   ├── 回复 2
│   └── 回复 3
└── 消息 3
```

### 2.3 OpenClaw 中的 Thread 操作

```bash
# 创建 Thread
openclaw message thread-create \
  --channel general \
  --name "项目讨论" \
  --message "开始讨论..."

# 回复 Thread
openclaw message thread-reply \
  --thread-id 123456789 \
  --message "我的观点..."

# 列出 Thread
openclaw message thread-list \
  --channel general
```

### 2.4 Thread 的特点

| 特性 | 说明 |
|------|------|
| **轻量级** | 只是消息的归类组织方式 |
| **平台依赖** | 依赖 Discord 等聊天平台的功能 |
| **无隔离** | 与主会话共享同一个 AI 实例和上下文 |
| **易用性** | 用户可直接在界面操作，无需代码 |

---

## 3. 什么是子 Session

### 3.1 概念定义

**子 Session（Sub-session）**是 OpenClaw 的 `sessions_spawn` 功能创建的**独立隔离会话**。

### 3.2 核心机制

```
主 Session (Main)
├── 上下文历史 A
├── 上下文历史 B
└── 🚀 启动子 Session
    ├── 独立的上下文历史
    ├── 独立的工具调用记录
    └── 独立的记忆空间
    
    子 Session 完成后 → 结果返回主 Session
```

### 3.3 子 Session 的使用

#### 命令行方式

```bash
# 启动子 Session 执行任务
openclaw sessions_spawn \
  --task "分析这份代码的安全性" \
  --model kimi-coding/k2p5 \
  --timeout 300
```

#### 编程方式（Skill 内部）

```python
# 在 Skill 中调用子 Session
result = await sessions_spawn(
    task="深入分析用户提供的代码",
    agent_id="code-analyzer",
    model="kimi-coding/k2p5",
    run_timeout_seconds=300,
    cleanup="delete"  # 完成后自动清理
)

# 使用子 Session 的结果
print(result.output)
```

### 3.4 子 Session 的特点

| 特性 | 说明 |
|------|------|
| **完全隔离** | 独立的上下文、记忆、工具调用历史 |
| **异步执行** | 不阻塞主 Session 的响应 |
| **可指定模型** | 可以为子任务选择不同的 AI 模型 |
| **超时控制** | 可设置独立的执行时间限制 |
| **自动清理** | 支持完成后自动删除，节省资源 |
| **结果回传** | 完成后结果返回到主 Session |

---

## 4. 核心区别对比

| 维度 | Thread | 子 Session |
|------|--------|------------|
| **本质** | 消息组织方式 | 独立执行环境 |
| **隔离性** | ❌ 无隔离，共享上下文 | ✅ 完全隔离，独立上下文 |
| **AI 实例** | 同一个 | 独立的 |
| **记忆共享** | 完全共享 | 不共享（除非显式传递） |
| **执行方式** | 同步、即时 | 异步、后台 |
| **适用场景** | 话题归类、简单讨论 | 复杂任务、耗时操作 |
| **平台依赖** | 依赖 Discord/Slack 等 | OpenClaw 原生功能 |
| **超时控制** | 无 | 可设置 |
| **模型选择** | 固定 | 可为子任务选不同模型 |
| **资源占用** | 低 | 相对较高 |

### 对比图示

```
┌─────────────────────────────────────────────────────────────────┐
│                        Thread 模式                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   用户提问 ──→ AI 回复 ──→ 用户追问 ──→ AI 回复                  │
│      │           │           │           │                      │
│      └───────────┴───────────┴───────────┘                      │
│              共享同一个上下文历史                                │
│                                                                 │
│   📝 只是消息的归类，AI 还是同一个                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      子 Session 模式                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   主 Session: "帮我分析这个项目的代码"                           │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────┐                       │
│   │ 🚀 启动子 Session (隔离环境)         │                       │
│   │                                     │                       │
│   │  • 独立的上下文                     │                       │
│   │  • 独立的模型配置                   │                       │
│   │  • 耗时操作不影响主会话             │                       │
│   │                                     │                       │
│   │  分析完成 ──→ 返回结果              │                       │
│   └─────────────────────────────────────┘                       │
│        │                                                        │
│        ▼                                                        │
│   主 Session: "分析完成，结果是..."                              │
│                                                                 │
│   🔄 真正的并行处理，完全隔离                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 使用场景与最佳实践

### 5.1 什么时候用 Thread？

✅ **适合使用 Thread 的场景：**

1. **话题归类**
   - 在繁忙频道中创建独立讨论区
   - 避免主频道消息过于杂乱

2. **简单问答串**
   - 围绕单一主题的连续对话
   - 不需要复杂的上下文隔离

3. **用户协作**
   - 多人在特定话题下讨论
   - 利用 Discord 的原生界面功能

**示例：**
```
#github 频道中：
用户 A: "这个 PR 有问题..."
    └─ 🧵 Thread: "PR #123 讨论"
        ├── 用户 B: "我看了代码..."
        ├── 用户 C: "建议修改这里..."
        └── AI: "总结：需要修改..."
```

### 5.2 什么时候用子 Session？

✅ **适合使用子 Session 的场景：**

1. **耗时操作**
   ```python
   # 分析大型代码库
   sessions_spawn(
       task="分析整个项目的依赖关系",
       timeout=600  # 10分钟超时
   )
   ```

2. **需要不同模型的任务**
   ```python
   # 主会话用轻量级模型，复杂任务用强模型
   sessions_spawn(
       task="深度推理这个算法问题",
       model="claude-sonnet-4-20250514"  # 强模型
   )
   ```

3. **隔离敏感操作**
   ```python
   # 在隔离环境中执行可能有风险的操作
   sessions_spawn(
       task="测试这段代码",
       cleanup="delete"  # 完成后清理
   )
   ```

4. **并行处理多个任务**
   ```python
   # 同时分析多个文件
   tasks = [
       sessions_spawn(task=f"分析 {file}") 
       for file in files
   ]
   results = await asyncio.gather(*tasks)
   ```

5. **避免上下文污染**
   ```python
   # 长文档处理，避免上下文溢出
   sessions_spawn(
       task="总结这份100页的报告",
       thinking="high"  # 高强度思考
   )
   ```

### 5.3 决策流程图

```
                    开始
                     │
                     ▼
            ┌─────────────────┐
            │ 任务是否复杂或   │
            │ 需要长时间运行？ │
            └─────────────────┘
                     │
           ┌────────┴────────┐
           ▼                 ▼
          是                否
           │                 │
           ▼                 ▼
   ┌──────────────┐   ┌──────────────┐
   │ 是否需要隔离  │   │  是否需要    │
   │ 上下文？      │   │  归类消息？  │
   └──────────────┘   └──────────────┘
           │                 │
     ┌─────┴─────┐     ┌────┴────┐
     ▼           ▼     ▼         ▼
    是          否    是         否
     │           │     │         │
     ▼           ▼     ▼         ▼
 ┌────────┐  ┌────────┐ │    ┌──────────┐
 │ 子     │  │ 子     │ │    │ 直接回复  │
 │ Session│  │ Session│ └────┤ (主会话) │
 │ +隔离  │  │ 无隔离 │      └──────────┘
 └────────┘  └────────┘           │
      │                         │
      │      ┌────────────┐     │
      └─────→│   Thread   │←────┘
             │ 消息归类   │
             └────────────┘
```

---

## 6. 总结

### Thread vs 子 Session 一句话总结

| 概念 | 一句话描述 |
|------|-----------|
| **Thread** | "把相关的消息放在一个文件夹里" |
| **子 Session** | "派一个专门的小助手去独立完成任务" |

### 选择建议

1. **只是想把消息归类** → 用 **Thread**
2. **任务复杂、耗时长、需要隔离** → 用 **子 Session**
3. **需要不同模型处理** → 用 **子 Session**
4. **多人围绕话题讨论** → 用 **Thread**

### 最佳实践 checklist

- [ ] 评估任务复杂度，选择合适的机制
- [ ] 子 Session 设置合理的超时时间
- [ ] 子 Session 完成后及时清理资源
- [ ] Thread 用于组织讨论，子 Session 用于执行任务
- [ ] 充分利用子 Session 的模型选择能力

---

## 参考资源

- OpenClaw 官方文档：https://docs.openclaw.ai
- OpenClaw GitHub：https://github.com/openclaw/openclaw
- 技能市场：https://clawhub.com

---

*本教程由 OpenClaw AI 助手整理编写*
*最后更新时间：2026-02-06 13:47:00 CST*
